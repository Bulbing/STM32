## 设计第一阶段：
* 暂时先下了一份keil5上跑的工程，闲下来看能直接拿keil5跑不  
* 这个文件里有TextLCD,HC-SR04的cpp和h文件，以供参考  
* HC-SR04的硬件接发很简单，只有4个pin，试着去用一下啊另一款5个pin的(HY-)，搞清楚他们之间的区别。  
* LCD的引脚图具体见：[LCD引脚链接](http://c.biancheng.net/cpp/html/1929.html)   
  上面LCD引脚的链接写的内容基本是ok的，就差V0处接地没写，记得自己连线的时候记住。
* 后期制作还有一个灯，如果时间条件允许，还可以加个出声的蜂鸣器或者喇叭  
* 疑惑问题：昨天用digitalout来控制LCD出来的满屏方块，换成analoout就正常了。暂时没搞清楚为什么。而且用arduino来跑也是同一个问题。

## 设计第二阶段：
*整个功能实现已经完成了。分成4个板块：LCD显示，超声波测距模块，LED灯随距离改变闪烁频率改变，蜂鸣器随距离改变闪烁频率改变* 
* 剩下就是代码加注释和看懂库函数，最重要的是算清楚超声波测距的原理公式，测距值dist（cm）和停留时间t（s）的关系。有时间也弄懂一下LCD库函数里的显示写法*  
  特别是cpp中的class写法
### 关于超声波测距的解释： 
  1.硬件：HC-SR04两个引脚连单片机，一个trigger，一个echo，分别连A6,A7  
  2.软件：主要是看懂(头文件.h)和(.cpp文件)  
  *首先知道（.h文件）里写的是HC-SR04的类库，（.cpp）文件中需要调用。（.h文件）中设置了类（class），分为public，private，public和private其中包含了(.cpp文件）中需要具体写内容的函数*  
  *关于条件编译命令:(#ifdef MBED_HCSR04_H)语句查找标识符MBED_HCSR04是否在程序的其他位置被#define定义过。若没有被定义过，则定义该标识符。这样的写法主要是为了防止重复的包含某文件，避免程序编译错误*
```
    #ifdef MBED_HCSR04_H  
    #define MBED_HCSR04_H  
    #endif  
```  
  *关于触发过后到接受到回声，用pulsedur = pulsetime.read_us();获得时间t，根据计算s=vt，注意单位转化，最后得出公式distance= (pulsedur*343)/20000;算出s，即完成测距，但是测距值为整数，单位是cm（sis为整数是因为之前在.h文件中写函数返回值已经定义为 unsigned int get_dist_cm(void);）  
  *关于触发，接收，reset等函数暂不追究其具体写法，等到我把cpp的内容再多了解一些。*  
  
### 关于LCD显示的学习内容：
  1.硬件连接的内容已经在第一阶段的链接里给出了。    
  2.软件：主要也是看一下库函数里有什么可以学习的东西没有，弄清楚main函数里的几个调用是什么功能    
  *cls:初始化光标的位置，因为这个显示器是2*16的，所以用cls（）函数初始化光标位置为（0，0）*  
  *locate:我理解的这个函数，因为看cpp文件中函数的赋值，认为是实现实时显示数据的一种方法*    
  ```
  void TextLCD::locate(int column, int row) {
    _column = column;
    _row = row;
 ```
   *printf函数可在.h文件中找到原函数，以上几个函数都可以在class文件中找到写法，来仿写即可*
 ## 设计第三阶段
 ### 主要是一些细节上和理论上的查缺补漏，把不会的列出来以后补完基础知识再看
   1.添加LED和有源蜂鸣器，调节其频率，因为他们都是距离越近，频率越快，也就是说wait的时间越短，所以因为wait时间和dis的值为正比关系，只用调节系数即可，不用使用映射来求一个复杂函数关系。  
   2.因为dist的单位为cm，数值可以变得很小，所以选择把t设置为float，参数400.0这个值是根据效果调出来的，为了显示方便，尽量选择了一个除出来数值简单的系数  
   3.关于测量距离范围的细节：  
   *根据自己的经验，测量距离大概在230左右为上限。因为时间问题，仅查了一点stm32比较general的测距范围，给出的理由与储存大小有关，[链接](https://blog.csdn.net/Zach_z/article/details/53648611),内容涉及溢出，目前不懂。等以后学了更多的底层再来看*  
